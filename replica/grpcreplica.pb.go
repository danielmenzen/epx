// Code generated by protoc-gen-gogo.
// source: grpcreplica.proto
// DO NOT EDIT!

/*
	Package replica is a generated protocol buffer package.

	It is generated from these files:
		grpcreplica.proto

	It has these top-level messages:
		PreAcceptReply
		Empty
		Command
		ClientProposal
		ProposalReplyTS
		ProposalRead
		ProposalReadReply
		Beacon
		BeaconReply
		PingArgs
		Preparation
		PreparationReply
		PreAcceptance
		PreAcceptanceReply
		PreAcceptanceOk
		Acceptance
		AcceptanceReply
		TryCommit
		TryCommitShort
		TryPreAcceptance
		TryPreAcceptanceReply
*/
package replica

import proto "github.com/golang/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"
import fmt "fmt"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type Status int32

const (
	Status_NONE           Status = 0
	Status_PREACCEPTED    Status = 1
	Status_PREACCEPTED_EQ Status = 2
	Status_ACCEPTED       Status = 3
	Status_COMMITTED      Status = 4
	Status_EXECUTED       Status = 5
)

var Status_name = map[int32]string{
	0: "NONE",
	1: "PREACCEPTED",
	2: "PREACCEPTED_EQ",
	3: "ACCEPTED",
	4: "COMMITTED",
	5: "EXECUTED",
}
var Status_value = map[string]int32{
	"NONE":           0,
	"PREACCEPTED":    1,
	"PREACCEPTED_EQ": 2,
	"ACCEPTED":       3,
	"COMMITTED":      4,
	"EXECUTED":       5,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

type PreAcceptReply_Type int32

const (
	PreAcceptReply_PREACCEPTREPLY PreAcceptReply_Type = 0
	PreAcceptReply_PREACCEPTOK    PreAcceptReply_Type = 1
)

var PreAcceptReply_Type_name = map[int32]string{
	0: "PREACCEPTREPLY",
	1: "PREACCEPTOK",
}
var PreAcceptReply_Type_value = map[string]int32{
	"PREACCEPTREPLY": 0,
	"PREACCEPTOK":    1,
}

func (x PreAcceptReply_Type) String() string {
	return proto.EnumName(PreAcceptReply_Type_name, int32(x))
}

type Command_Operation int32

const (
	Command_NOP    Command_Operation = 0
	Command_PUT    Command_Operation = 1
	Command_GET    Command_Operation = 2
	Command_DELETE Command_Operation = 3
	Command_RLOCK  Command_Operation = 4
	Command_WLOCK  Command_Operation = 5
)

var Command_Operation_name = map[int32]string{
	0: "NOP",
	1: "PUT",
	2: "GET",
	3: "DELETE",
	4: "RLOCK",
	5: "WLOCK",
}
var Command_Operation_value = map[string]int32{
	"NOP":    0,
	"PUT":    1,
	"GET":    2,
	"DELETE": 3,
	"RLOCK":  4,
	"WLOCK":  5,
}

func (x Command_Operation) String() string {
	return proto.EnumName(Command_Operation_name, int32(x))
}

type PreAcceptReply struct {
	Type               PreAcceptReply_Type `protobuf:"varint,1,opt,name=type,proto3,enum=replica.PreAcceptReply_Type" json:"type,omitempty"`
	PreAcceptanceReply *PreAcceptanceReply `protobuf:"bytes,2,opt,name=preAcceptanceReply" json:"preAcceptanceReply,omitempty"`
	PreAcceptanceOk    *PreAcceptanceOk    `protobuf:"bytes,3,opt,name=preAcceptanceOk" json:"preAcceptanceOk,omitempty"`
}

func (m *PreAcceptReply) Reset()         { *m = PreAcceptReply{} }
func (m *PreAcceptReply) String() string { return proto.CompactTextString(m) }
func (*PreAcceptReply) ProtoMessage()    {}

func (m *PreAcceptReply) GetPreAcceptanceReply() *PreAcceptanceReply {
	if m != nil {
		return m.PreAcceptanceReply
	}
	return nil
}

func (m *PreAcceptReply) GetPreAcceptanceOk() *PreAcceptanceOk {
	if m != nil {
		return m.PreAcceptanceOk
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}

type Command struct {
	Operation Command_Operation `protobuf:"varint,1,opt,name=operation,proto3,enum=replica.Command_Operation" json:"operation,omitempty"`
	Key       string            `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value     []byte            `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Command) Reset()         { *m = Command{} }
func (m *Command) String() string { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()    {}

type ClientProposal struct {
	CommandId int32    `protobuf:"varint,1,opt,name=command_id,proto3" json:"command_id,omitempty"`
	Command   *Command `protobuf:"bytes,2,opt,name=command" json:"command,omitempty"`
	Timestamp int64    `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *ClientProposal) Reset()         { *m = ClientProposal{} }
func (m *ClientProposal) String() string { return proto.CompactTextString(m) }
func (*ClientProposal) ProtoMessage()    {}

func (m *ClientProposal) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

type ProposalReplyTS struct {
	Ok        bool   `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	Command   int32  `protobuf:"varint,2,opt,name=command,proto3" json:"command,omitempty"`
	Value     []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Timestamp int64  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *ProposalReplyTS) Reset()         { *m = ProposalReplyTS{} }
func (m *ProposalReplyTS) String() string { return proto.CompactTextString(m) }
func (*ProposalReplyTS) ProtoMessage()    {}

type ProposalRead struct {
	CommandId int32    `protobuf:"varint,1,opt,name=command_id,proto3" json:"command_id,omitempty"`
	Command   *Command `protobuf:"bytes,2,opt,name=command" json:"command,omitempty"`
	Key       string   `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *ProposalRead) Reset()         { *m = ProposalRead{} }
func (m *ProposalRead) String() string { return proto.CompactTextString(m) }
func (*ProposalRead) ProtoMessage()    {}

func (m *ProposalRead) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

type ProposalReadReply struct {
	Command int32  `protobuf:"varint,1,opt,name=command,proto3" json:"command,omitempty"`
	Ok      int32  `protobuf:"varint,2,opt,name=ok,proto3" json:"ok,omitempty"`
	Value   []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ProposalReadReply) Reset()         { *m = ProposalReadReply{} }
func (m *ProposalReadReply) String() string { return proto.CompactTextString(m) }
func (*ProposalReadReply) ProtoMessage()    {}

type Beacon struct {
	Replica   int32  `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *Beacon) Reset()         { *m = Beacon{} }
func (m *Beacon) String() string { return proto.CompactTextString(m) }
func (*Beacon) ProtoMessage()    {}

type BeaconReply struct {
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Replica   int32  `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
}

func (m *BeaconReply) Reset()         { *m = BeaconReply{} }
func (m *BeaconReply) String() string { return proto.CompactTextString(m) }
func (*BeaconReply) ProtoMessage()    {}

type PingArgs struct {
	ActAsLeader int32 `protobuf:"varint,1,opt,name=act_as_leader,proto3" json:"act_as_leader,omitempty"`
}

func (m *PingArgs) Reset()         { *m = PingArgs{} }
func (m *PingArgs) String() string { return proto.CompactTextString(m) }
func (*PingArgs) ProtoMessage()    {}

type Preparation struct {
	Leader   int32 `protobuf:"varint,1,opt,name=leader,proto3" json:"leader,omitempty"`
	Replica  int32 `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32 `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Ballot   int32 `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
}

func (m *Preparation) Reset()         { *m = Preparation{} }
func (m *Preparation) String() string { return proto.CompactTextString(m) }
func (*Preparation) ProtoMessage()    {}

type PreparationReply struct {
	Acceptor int32      `protobuf:"varint,1,opt,name=acceptor,proto3" json:"acceptor,omitempty"`
	Replica  int32      `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32      `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Ok       bool       `protobuf:"varint,4,opt,name=ok,proto3" json:"ok,omitempty"`
	Ballot   int32      `protobuf:"varint,5,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Status   Status     `protobuf:"varint,6,opt,name=status,proto3,enum=replica.Status" json:"status,omitempty"`
	Commands []*Command `protobuf:"bytes,7,rep,name=commands" json:"commands,omitempty"`
	Seq      int32      `protobuf:"varint,8,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32    `protobuf:"varint,9,rep,packed,name=deps" json:"deps,omitempty"`
}

func (m *PreparationReply) Reset()         { *m = PreparationReply{} }
func (m *PreparationReply) String() string { return proto.CompactTextString(m) }
func (*PreparationReply) ProtoMessage()    {}

func (m *PreparationReply) GetCommands() []*Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

type PreAcceptance struct {
	Leader   int32      `protobuf:"varint,1,opt,name=leader,proto3" json:"leader,omitempty"`
	Replica  int32      `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32      `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Ballot   int32      `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Commands []*Command `protobuf:"bytes,5,rep,name=commands" json:"commands,omitempty"`
	Seq      int32      `protobuf:"varint,6,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32    `protobuf:"varint,7,rep,packed,name=deps" json:"deps,omitempty"`
}

func (m *PreAcceptance) Reset()         { *m = PreAcceptance{} }
func (m *PreAcceptance) String() string { return proto.CompactTextString(m) }
func (*PreAcceptance) ProtoMessage()    {}

func (m *PreAcceptance) GetCommands() []*Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

type PreAcceptanceReply struct {
	Replica       int32   `protobuf:"varint,1,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance      int32   `protobuf:"varint,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Ok            bool    `protobuf:"varint,3,opt,name=ok,proto3" json:"ok,omitempty"`
	Ballot        int32   `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Seq           int32   `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps          []int32 `protobuf:"varint,6,rep,packed,name=deps" json:"deps,omitempty"`
	CommittedDeps []int32 `protobuf:"varint,7,rep,packed,name=committed_deps" json:"committed_deps,omitempty"`
}

func (m *PreAcceptanceReply) Reset()         { *m = PreAcceptanceReply{} }
func (m *PreAcceptanceReply) String() string { return proto.CompactTextString(m) }
func (*PreAcceptanceReply) ProtoMessage()    {}

type PreAcceptanceOk struct {
	Instance int32 `protobuf:"varint,1,opt,name=instance,proto3" json:"instance,omitempty"`
}

func (m *PreAcceptanceOk) Reset()         { *m = PreAcceptanceOk{} }
func (m *PreAcceptanceOk) String() string { return proto.CompactTextString(m) }
func (*PreAcceptanceOk) ProtoMessage()    {}

type Acceptance struct {
	Leader   int32   `protobuf:"varint,1,opt,name=leader,proto3" json:"leader,omitempty"`
	Replica  int32   `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32   `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Ballot   int32   `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Count    int32   `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	Seq      int32   `protobuf:"varint,6,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32 `protobuf:"varint,7,rep,packed,name=deps" json:"deps,omitempty"`
}

func (m *Acceptance) Reset()         { *m = Acceptance{} }
func (m *Acceptance) String() string { return proto.CompactTextString(m) }
func (*Acceptance) ProtoMessage()    {}

type AcceptanceReply struct {
	Replica  int32 `protobuf:"varint,1,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32 `protobuf:"varint,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Ok       bool  `protobuf:"varint,3,opt,name=ok,proto3" json:"ok,omitempty"`
	Ballot   int32 `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
}

func (m *AcceptanceReply) Reset()         { *m = AcceptanceReply{} }
func (m *AcceptanceReply) String() string { return proto.CompactTextString(m) }
func (*AcceptanceReply) ProtoMessage()    {}

type TryCommit struct {
	Leader   int32      `protobuf:"varint,1,opt,name=leader,proto3" json:"leader,omitempty"`
	Replica  int32      `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32      `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Commands []*Command `protobuf:"bytes,4,rep,name=commands" json:"commands,omitempty"`
	Seq      int32      `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32    `protobuf:"varint,6,rep,packed,name=deps" json:"deps,omitempty"`
}

func (m *TryCommit) Reset()         { *m = TryCommit{} }
func (m *TryCommit) String() string { return proto.CompactTextString(m) }
func (*TryCommit) ProtoMessage()    {}

func (m *TryCommit) GetCommands() []*Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

type TryCommitShort struct {
	Leader   int32   `protobuf:"varint,1,opt,name=leader,proto3" json:"leader,omitempty"`
	Replica  int32   `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32   `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Count    int32   `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Seq      int32   `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32 `protobuf:"varint,6,rep,packed,name=deps" json:"deps,omitempty"`
}

func (m *TryCommitShort) Reset()         { *m = TryCommitShort{} }
func (m *TryCommitShort) String() string { return proto.CompactTextString(m) }
func (*TryCommitShort) ProtoMessage()    {}

type TryPreAcceptance struct {
	Leader   int32      `protobuf:"varint,1,opt,name=leader,proto3" json:"leader,omitempty"`
	Replica  int32      `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance int32      `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Ballot   int32      `protobuf:"varint,4,opt,name=ballot,proto3" json:"ballot,omitempty"`
	Commands []*Command `protobuf:"bytes,5,rep,name=commands" json:"commands,omitempty"`
	Seq      int32      `protobuf:"varint,6,opt,name=seq,proto3" json:"seq,omitempty"`
	Deps     []int32    `protobuf:"varint,7,rep,packed,name=deps" json:"deps,omitempty"`
}

func (m *TryPreAcceptance) Reset()         { *m = TryPreAcceptance{} }
func (m *TryPreAcceptance) String() string { return proto.CompactTextString(m) }
func (*TryPreAcceptance) ProtoMessage()    {}

func (m *TryPreAcceptance) GetCommands() []*Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

type TryPreAcceptanceReply struct {
	Acceptor         int32  `protobuf:"varint,1,opt,name=acceptor,proto3" json:"acceptor,omitempty"`
	Replica          int32  `protobuf:"varint,2,opt,name=replica,proto3" json:"replica,omitempty"`
	Instance         int32  `protobuf:"varint,3,opt,name=instance,proto3" json:"instance,omitempty"`
	Ok               bool   `protobuf:"varint,4,opt,name=ok,proto3" json:"ok,omitempty"`
	Ballot           int32  `protobuf:"varint,5,opt,name=ballot,proto3" json:"ballot,omitempty"`
	ConflictReplica  int32  `protobuf:"varint,6,opt,name=conflict_replica,proto3" json:"conflict_replica,omitempty"`
	ConflictInstance int32  `protobuf:"varint,7,opt,name=conflict_instance,proto3" json:"conflict_instance,omitempty"`
	ConflictStatus   Status `protobuf:"varint,8,opt,name=conflict_status,proto3,enum=replica.Status" json:"conflict_status,omitempty"`
}

func (m *TryPreAcceptanceReply) Reset()         { *m = TryPreAcceptanceReply{} }
func (m *TryPreAcceptanceReply) String() string { return proto.CompactTextString(m) }
func (*TryPreAcceptanceReply) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("replica.Status", Status_name, Status_value)
	proto.RegisterEnum("replica.PreAcceptReply_Type", PreAcceptReply_Type_name, PreAcceptReply_Type_value)
	proto.RegisterEnum("replica.Command_Operation", Command_Operation_name, Command_Operation_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for GrpcReplica service

type GrpcReplicaClient interface {
	Ping(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_PingClient, error)
	Propose(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_ProposeClient, error)
	ProposeAndRead(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_ProposeAndReadClient, error)
	Prepare(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_PrepareClient, error)
	TryPreAccept(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_TryPreAcceptClient, error)
	PreAccept(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_PreAcceptClient, error)
	Accept(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_AcceptClient, error)
	Commit(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_CommitClient, error)
	CommitShort(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_CommitShortClient, error)
}

type grpcReplicaClient struct {
	cc *grpc.ClientConn
}

func NewGrpcReplicaClient(cc *grpc.ClientConn) GrpcReplicaClient {
	return &grpcReplicaClient{cc}
}

func (c *grpcReplicaClient) Ping(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_PingClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GrpcReplica_serviceDesc.Streams[0], c.cc, "/replica.GrpcReplica/Ping", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcReplicaPingClient{stream}
	return x, nil
}

type GrpcReplica_PingClient interface {
	Send(*Beacon) error
	Recv() (*BeaconReply, error)
	grpc.ClientStream
}

type grpcReplicaPingClient struct {
	grpc.ClientStream
}

func (x *grpcReplicaPingClient) Send(m *Beacon) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcReplicaPingClient) Recv() (*BeaconReply, error) {
	m := new(BeaconReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcReplicaClient) Propose(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_ProposeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GrpcReplica_serviceDesc.Streams[1], c.cc, "/replica.GrpcReplica/Propose", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcReplicaProposeClient{stream}
	return x, nil
}

type GrpcReplica_ProposeClient interface {
	Send(*ClientProposal) error
	Recv() (*ProposalReplyTS, error)
	grpc.ClientStream
}

type grpcReplicaProposeClient struct {
	grpc.ClientStream
}

func (x *grpcReplicaProposeClient) Send(m *ClientProposal) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcReplicaProposeClient) Recv() (*ProposalReplyTS, error) {
	m := new(ProposalReplyTS)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcReplicaClient) ProposeAndRead(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_ProposeAndReadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GrpcReplica_serviceDesc.Streams[2], c.cc, "/replica.GrpcReplica/ProposeAndRead", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcReplicaProposeAndReadClient{stream}
	return x, nil
}

type GrpcReplica_ProposeAndReadClient interface {
	Send(*ProposalRead) error
	Recv() (*ProposalReadReply, error)
	grpc.ClientStream
}

type grpcReplicaProposeAndReadClient struct {
	grpc.ClientStream
}

func (x *grpcReplicaProposeAndReadClient) Send(m *ProposalRead) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcReplicaProposeAndReadClient) Recv() (*ProposalReadReply, error) {
	m := new(ProposalReadReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcReplicaClient) Prepare(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_PrepareClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GrpcReplica_serviceDesc.Streams[3], c.cc, "/replica.GrpcReplica/Prepare", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcReplicaPrepareClient{stream}
	return x, nil
}

type GrpcReplica_PrepareClient interface {
	Send(*Preparation) error
	Recv() (*PreparationReply, error)
	grpc.ClientStream
}

type grpcReplicaPrepareClient struct {
	grpc.ClientStream
}

func (x *grpcReplicaPrepareClient) Send(m *Preparation) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcReplicaPrepareClient) Recv() (*PreparationReply, error) {
	m := new(PreparationReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcReplicaClient) TryPreAccept(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_TryPreAcceptClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GrpcReplica_serviceDesc.Streams[4], c.cc, "/replica.GrpcReplica/TryPreAccept", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcReplicaTryPreAcceptClient{stream}
	return x, nil
}

type GrpcReplica_TryPreAcceptClient interface {
	Send(*TryPreAcceptance) error
	Recv() (*TryPreAcceptanceReply, error)
	grpc.ClientStream
}

type grpcReplicaTryPreAcceptClient struct {
	grpc.ClientStream
}

func (x *grpcReplicaTryPreAcceptClient) Send(m *TryPreAcceptance) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcReplicaTryPreAcceptClient) Recv() (*TryPreAcceptanceReply, error) {
	m := new(TryPreAcceptanceReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcReplicaClient) PreAccept(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_PreAcceptClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GrpcReplica_serviceDesc.Streams[5], c.cc, "/replica.GrpcReplica/PreAccept", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcReplicaPreAcceptClient{stream}
	return x, nil
}

type GrpcReplica_PreAcceptClient interface {
	Send(*PreAcceptance) error
	Recv() (*PreAcceptReply, error)
	grpc.ClientStream
}

type grpcReplicaPreAcceptClient struct {
	grpc.ClientStream
}

func (x *grpcReplicaPreAcceptClient) Send(m *PreAcceptance) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcReplicaPreAcceptClient) Recv() (*PreAcceptReply, error) {
	m := new(PreAcceptReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcReplicaClient) Accept(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_AcceptClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GrpcReplica_serviceDesc.Streams[6], c.cc, "/replica.GrpcReplica/Accept", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcReplicaAcceptClient{stream}
	return x, nil
}

type GrpcReplica_AcceptClient interface {
	Send(*Acceptance) error
	Recv() (*AcceptanceReply, error)
	grpc.ClientStream
}

type grpcReplicaAcceptClient struct {
	grpc.ClientStream
}

func (x *grpcReplicaAcceptClient) Send(m *Acceptance) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcReplicaAcceptClient) Recv() (*AcceptanceReply, error) {
	m := new(AcceptanceReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcReplicaClient) Commit(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_CommitClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GrpcReplica_serviceDesc.Streams[7], c.cc, "/replica.GrpcReplica/Commit", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcReplicaCommitClient{stream}
	return x, nil
}

type GrpcReplica_CommitClient interface {
	Send(*TryCommit) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type grpcReplicaCommitClient struct {
	grpc.ClientStream
}

func (x *grpcReplicaCommitClient) Send(m *TryCommit) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcReplicaCommitClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *grpcReplicaClient) CommitShort(ctx context.Context, opts ...grpc.CallOption) (GrpcReplica_CommitShortClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GrpcReplica_serviceDesc.Streams[8], c.cc, "/replica.GrpcReplica/CommitShort", opts...)
	if err != nil {
		return nil, err
	}
	x := &grpcReplicaCommitShortClient{stream}
	return x, nil
}

type GrpcReplica_CommitShortClient interface {
	Send(*TryCommitShort) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type grpcReplicaCommitShortClient struct {
	grpc.ClientStream
}

func (x *grpcReplicaCommitShortClient) Send(m *TryCommitShort) error {
	return x.ClientStream.SendMsg(m)
}

func (x *grpcReplicaCommitShortClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for GrpcReplica service

type GrpcReplicaServer interface {
	Ping(GrpcReplica_PingServer) error
	Propose(GrpcReplica_ProposeServer) error
	ProposeAndRead(GrpcReplica_ProposeAndReadServer) error
	Prepare(GrpcReplica_PrepareServer) error
	TryPreAccept(GrpcReplica_TryPreAcceptServer) error
	PreAccept(GrpcReplica_PreAcceptServer) error
	Accept(GrpcReplica_AcceptServer) error
	Commit(GrpcReplica_CommitServer) error
	CommitShort(GrpcReplica_CommitShortServer) error
}

func RegisterGrpcReplicaServer(s *grpc.Server, srv GrpcReplicaServer) {
	s.RegisterService(&_GrpcReplica_serviceDesc, srv)
}

func _GrpcReplica_Ping_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcReplicaServer).Ping(&grpcReplicaPingServer{stream})
}

type GrpcReplica_PingServer interface {
	Send(*BeaconReply) error
	Recv() (*Beacon, error)
	grpc.ServerStream
}

type grpcReplicaPingServer struct {
	grpc.ServerStream
}

func (x *grpcReplicaPingServer) Send(m *BeaconReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcReplicaPingServer) Recv() (*Beacon, error) {
	m := new(Beacon)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcReplica_Propose_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcReplicaServer).Propose(&grpcReplicaProposeServer{stream})
}

type GrpcReplica_ProposeServer interface {
	Send(*ProposalReplyTS) error
	Recv() (*ClientProposal, error)
	grpc.ServerStream
}

type grpcReplicaProposeServer struct {
	grpc.ServerStream
}

func (x *grpcReplicaProposeServer) Send(m *ProposalReplyTS) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcReplicaProposeServer) Recv() (*ClientProposal, error) {
	m := new(ClientProposal)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcReplica_ProposeAndRead_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcReplicaServer).ProposeAndRead(&grpcReplicaProposeAndReadServer{stream})
}

type GrpcReplica_ProposeAndReadServer interface {
	Send(*ProposalReadReply) error
	Recv() (*ProposalRead, error)
	grpc.ServerStream
}

type grpcReplicaProposeAndReadServer struct {
	grpc.ServerStream
}

func (x *grpcReplicaProposeAndReadServer) Send(m *ProposalReadReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcReplicaProposeAndReadServer) Recv() (*ProposalRead, error) {
	m := new(ProposalRead)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcReplica_Prepare_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcReplicaServer).Prepare(&grpcReplicaPrepareServer{stream})
}

type GrpcReplica_PrepareServer interface {
	Send(*PreparationReply) error
	Recv() (*Preparation, error)
	grpc.ServerStream
}

type grpcReplicaPrepareServer struct {
	grpc.ServerStream
}

func (x *grpcReplicaPrepareServer) Send(m *PreparationReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcReplicaPrepareServer) Recv() (*Preparation, error) {
	m := new(Preparation)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcReplica_TryPreAccept_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcReplicaServer).TryPreAccept(&grpcReplicaTryPreAcceptServer{stream})
}

type GrpcReplica_TryPreAcceptServer interface {
	Send(*TryPreAcceptanceReply) error
	Recv() (*TryPreAcceptance, error)
	grpc.ServerStream
}

type grpcReplicaTryPreAcceptServer struct {
	grpc.ServerStream
}

func (x *grpcReplicaTryPreAcceptServer) Send(m *TryPreAcceptanceReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcReplicaTryPreAcceptServer) Recv() (*TryPreAcceptance, error) {
	m := new(TryPreAcceptance)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcReplica_PreAccept_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcReplicaServer).PreAccept(&grpcReplicaPreAcceptServer{stream})
}

type GrpcReplica_PreAcceptServer interface {
	Send(*PreAcceptReply) error
	Recv() (*PreAcceptance, error)
	grpc.ServerStream
}

type grpcReplicaPreAcceptServer struct {
	grpc.ServerStream
}

func (x *grpcReplicaPreAcceptServer) Send(m *PreAcceptReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcReplicaPreAcceptServer) Recv() (*PreAcceptance, error) {
	m := new(PreAcceptance)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcReplica_Accept_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcReplicaServer).Accept(&grpcReplicaAcceptServer{stream})
}

type GrpcReplica_AcceptServer interface {
	Send(*AcceptanceReply) error
	Recv() (*Acceptance, error)
	grpc.ServerStream
}

type grpcReplicaAcceptServer struct {
	grpc.ServerStream
}

func (x *grpcReplicaAcceptServer) Send(m *AcceptanceReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcReplicaAcceptServer) Recv() (*Acceptance, error) {
	m := new(Acceptance)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcReplica_Commit_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcReplicaServer).Commit(&grpcReplicaCommitServer{stream})
}

type GrpcReplica_CommitServer interface {
	SendAndClose(*Empty) error
	Recv() (*TryCommit, error)
	grpc.ServerStream
}

type grpcReplicaCommitServer struct {
	grpc.ServerStream
}

func (x *grpcReplicaCommitServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcReplicaCommitServer) Recv() (*TryCommit, error) {
	m := new(TryCommit)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GrpcReplica_CommitShort_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GrpcReplicaServer).CommitShort(&grpcReplicaCommitShortServer{stream})
}

type GrpcReplica_CommitShortServer interface {
	SendAndClose(*Empty) error
	Recv() (*TryCommitShort, error)
	grpc.ServerStream
}

type grpcReplicaCommitShortServer struct {
	grpc.ServerStream
}

func (x *grpcReplicaCommitShortServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *grpcReplicaCommitShortServer) Recv() (*TryCommitShort, error) {
	m := new(TryCommitShort)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GrpcReplica_serviceDesc = grpc.ServiceDesc{
	ServiceName: "replica.GrpcReplica",
	HandlerType: (*GrpcReplicaServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Ping",
			Handler:       _GrpcReplica_Ping_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Propose",
			Handler:       _GrpcReplica_Propose_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ProposeAndRead",
			Handler:       _GrpcReplica_ProposeAndRead_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Prepare",
			Handler:       _GrpcReplica_Prepare_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "TryPreAccept",
			Handler:       _GrpcReplica_TryPreAccept_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "PreAccept",
			Handler:       _GrpcReplica_PreAccept_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Accept",
			Handler:       _GrpcReplica_Accept_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Commit",
			Handler:       _GrpcReplica_Commit_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "CommitShort",
			Handler:       _GrpcReplica_CommitShort_Handler,
			ClientStreams: true,
		},
	},
}

func (m *PreAcceptReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PreAcceptReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Type))
	}
	if m.PreAcceptanceReply != nil {
		data[i] = 0x12
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.PreAcceptanceReply.Size()))
		n1, err := m.PreAcceptanceReply.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.PreAcceptanceOk != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.PreAcceptanceOk.Size()))
		n2, err := m.PreAcceptanceOk.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Empty) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Empty) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Command) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Command) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Operation))
	}
	if len(m.Key) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Value != nil {
		if len(m.Value) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintGrpcreplica(data, i, uint64(len(m.Value)))
			i += copy(data[i:], m.Value)
		}
	}
	return i, nil
}

func (m *ClientProposal) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ClientProposal) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommandId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.CommandId))
	}
	if m.Command != nil {
		data[i] = 0x12
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Command.Size()))
		n3, err := m.Command.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Timestamp != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Timestamp))
	}
	return i, nil
}

func (m *ProposalReplyTS) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProposalReplyTS) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ok {
		data[i] = 0x8
		i++
		if m.Ok {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Command != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Command))
	}
	if m.Value != nil {
		if len(m.Value) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintGrpcreplica(data, i, uint64(len(m.Value)))
			i += copy(data[i:], m.Value)
		}
	}
	if m.Timestamp != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Timestamp))
	}
	return i, nil
}

func (m *ProposalRead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProposalRead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommandId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.CommandId))
	}
	if m.Command != nil {
		data[i] = 0x12
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Command.Size()))
		n4, err := m.Command.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Key) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	return i, nil
}

func (m *ProposalReadReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProposalReadReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Command != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Command))
	}
	if m.Ok != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Ok))
	}
	if m.Value != nil {
		if len(m.Value) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintGrpcreplica(data, i, uint64(len(m.Value)))
			i += copy(data[i:], m.Value)
		}
	}
	return i, nil
}

func (m *Beacon) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Beacon) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Timestamp))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	return i, nil
}

func (m *BeaconReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BeaconReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Timestamp))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	return i, nil
}

func (m *PingArgs) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PingArgs) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActAsLeader != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.ActAsLeader))
	}
	return i, nil
}

func (m *Preparation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Preparation) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Leader != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Leader))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Ballot))
	}
	return i, nil
}

func (m *PreparationReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PreparationReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Acceptor != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Acceptor))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	if m.Ok {
		data[i] = 0x20
		i++
		if m.Ok {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Ballot != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Ballot))
	}
	if m.Status != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Status))
	}
	if len(m.Commands) > 0 {
		for _, msg := range m.Commands {
			data[i] = 0x3a
			i++
			i = encodeVarintGrpcreplica(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seq != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		data6 := make([]byte, len(m.Deps)*10)
		var j5 int
		for _, num1 := range m.Deps {
			num := uint64(num1)
			for num >= 1<<7 {
				data6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			data6[j5] = uint8(num)
			j5++
		}
		data[i] = 0x4a
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(j5))
		i += copy(data[i:], data6[:j5])
	}
	return i, nil
}

func (m *PreAcceptance) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PreAcceptance) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Leader != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Leader))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Ballot))
	}
	if len(m.Commands) > 0 {
		for _, msg := range m.Commands {
			data[i] = 0x2a
			i++
			i = encodeVarintGrpcreplica(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seq != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		data8 := make([]byte, len(m.Deps)*10)
		var j7 int
		for _, num1 := range m.Deps {
			num := uint64(num1)
			for num >= 1<<7 {
				data8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			data8[j7] = uint8(num)
			j7++
		}
		data[i] = 0x3a
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(j7))
		i += copy(data[i:], data8[:j7])
	}
	return i, nil
}

func (m *PreAcceptanceReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PreAcceptanceReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Replica != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	if m.Ok {
		data[i] = 0x18
		i++
		if m.Ok {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Ballot))
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		data10 := make([]byte, len(m.Deps)*10)
		var j9 int
		for _, num1 := range m.Deps {
			num := uint64(num1)
			for num >= 1<<7 {
				data10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			data10[j9] = uint8(num)
			j9++
		}
		data[i] = 0x32
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(j9))
		i += copy(data[i:], data10[:j9])
	}
	if len(m.CommittedDeps) > 0 {
		data12 := make([]byte, len(m.CommittedDeps)*10)
		var j11 int
		for _, num1 := range m.CommittedDeps {
			num := uint64(num1)
			for num >= 1<<7 {
				data12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			data12[j11] = uint8(num)
			j11++
		}
		data[i] = 0x3a
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(j11))
		i += copy(data[i:], data12[:j11])
	}
	return i, nil
}

func (m *PreAcceptanceOk) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PreAcceptanceOk) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Instance != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	return i, nil
}

func (m *Acceptance) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Acceptance) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Leader != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Leader))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Ballot))
	}
	if m.Count != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Count))
	}
	if m.Seq != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		data14 := make([]byte, len(m.Deps)*10)
		var j13 int
		for _, num1 := range m.Deps {
			num := uint64(num1)
			for num >= 1<<7 {
				data14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			data14[j13] = uint8(num)
			j13++
		}
		data[i] = 0x3a
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(j13))
		i += copy(data[i:], data14[:j13])
	}
	return i, nil
}

func (m *AcceptanceReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AcceptanceReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Replica != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	if m.Ok {
		data[i] = 0x18
		i++
		if m.Ok {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Ballot))
	}
	return i, nil
}

func (m *TryCommit) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TryCommit) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Leader != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Leader))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	if len(m.Commands) > 0 {
		for _, msg := range m.Commands {
			data[i] = 0x22
			i++
			i = encodeVarintGrpcreplica(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		data16 := make([]byte, len(m.Deps)*10)
		var j15 int
		for _, num1 := range m.Deps {
			num := uint64(num1)
			for num >= 1<<7 {
				data16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			data16[j15] = uint8(num)
			j15++
		}
		data[i] = 0x32
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(j15))
		i += copy(data[i:], data16[:j15])
	}
	return i, nil
}

func (m *TryCommitShort) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TryCommitShort) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Leader != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Leader))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	if m.Count != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Count))
	}
	if m.Seq != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		data18 := make([]byte, len(m.Deps)*10)
		var j17 int
		for _, num1 := range m.Deps {
			num := uint64(num1)
			for num >= 1<<7 {
				data18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			data18[j17] = uint8(num)
			j17++
		}
		data[i] = 0x32
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(j17))
		i += copy(data[i:], data18[:j17])
	}
	return i, nil
}

func (m *TryPreAcceptance) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TryPreAcceptance) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Leader != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Leader))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	if m.Ballot != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Ballot))
	}
	if len(m.Commands) > 0 {
		for _, msg := range m.Commands {
			data[i] = 0x2a
			i++
			i = encodeVarintGrpcreplica(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seq != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		data20 := make([]byte, len(m.Deps)*10)
		var j19 int
		for _, num1 := range m.Deps {
			num := uint64(num1)
			for num >= 1<<7 {
				data20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			data20[j19] = uint8(num)
			j19++
		}
		data[i] = 0x3a
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(j19))
		i += copy(data[i:], data20[:j19])
	}
	return i, nil
}

func (m *TryPreAcceptanceReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TryPreAcceptanceReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Acceptor != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Acceptor))
	}
	if m.Replica != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Replica))
	}
	if m.Instance != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Instance))
	}
	if m.Ok {
		data[i] = 0x20
		i++
		if m.Ok {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Ballot != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.Ballot))
	}
	if m.ConflictReplica != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.ConflictReplica))
	}
	if m.ConflictInstance != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.ConflictInstance))
	}
	if m.ConflictStatus != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintGrpcreplica(data, i, uint64(m.ConflictStatus))
	}
	return i, nil
}

func encodeFixed64Grpcreplica(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Grpcreplica(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGrpcreplica(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *PreAcceptReply) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Type))
	}
	if m.PreAcceptanceReply != nil {
		l = m.PreAcceptanceReply.Size()
		n += 1 + l + sovGrpcreplica(uint64(l))
	}
	if m.PreAcceptanceOk != nil {
		l = m.PreAcceptanceOk.Size()
		n += 1 + l + sovGrpcreplica(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Operation))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovGrpcreplica(uint64(l))
	}
	if m.Value != nil {
		l = len(m.Value)
		if l > 0 {
			n += 1 + l + sovGrpcreplica(uint64(l))
		}
	}
	return n
}

func (m *ClientProposal) Size() (n int) {
	var l int
	_ = l
	if m.CommandId != 0 {
		n += 1 + sovGrpcreplica(uint64(m.CommandId))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovGrpcreplica(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Timestamp))
	}
	return n
}

func (m *ProposalReplyTS) Size() (n int) {
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	if m.Command != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Command))
	}
	if m.Value != nil {
		l = len(m.Value)
		if l > 0 {
			n += 1 + l + sovGrpcreplica(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Timestamp))
	}
	return n
}

func (m *ProposalRead) Size() (n int) {
	var l int
	_ = l
	if m.CommandId != 0 {
		n += 1 + sovGrpcreplica(uint64(m.CommandId))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovGrpcreplica(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovGrpcreplica(uint64(l))
	}
	return n
}

func (m *ProposalReadReply) Size() (n int) {
	var l int
	_ = l
	if m.Command != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Command))
	}
	if m.Ok != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Ok))
	}
	if m.Value != nil {
		l = len(m.Value)
		if l > 0 {
			n += 1 + l + sovGrpcreplica(uint64(l))
		}
	}
	return n
}

func (m *Beacon) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Timestamp))
	}
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	return n
}

func (m *BeaconReply) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Timestamp))
	}
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	return n
}

func (m *PingArgs) Size() (n int) {
	var l int
	_ = l
	if m.ActAsLeader != 0 {
		n += 1 + sovGrpcreplica(uint64(m.ActAsLeader))
	}
	return n
}

func (m *Preparation) Size() (n int) {
	var l int
	_ = l
	if m.Leader != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Leader))
	}
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	if m.Ballot != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Ballot))
	}
	return n
}

func (m *PreparationReply) Size() (n int) {
	var l int
	_ = l
	if m.Acceptor != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Acceptor))
	}
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	if m.Ok {
		n += 2
	}
	if m.Ballot != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Ballot))
	}
	if m.Status != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Status))
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 1 + l + sovGrpcreplica(uint64(l))
		}
	}
	if m.Seq != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		l = 0
		for _, e := range m.Deps {
			l += sovGrpcreplica(uint64(e))
		}
		n += 1 + sovGrpcreplica(uint64(l)) + l
	}
	return n
}

func (m *PreAcceptance) Size() (n int) {
	var l int
	_ = l
	if m.Leader != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Leader))
	}
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	if m.Ballot != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Ballot))
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 1 + l + sovGrpcreplica(uint64(l))
		}
	}
	if m.Seq != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		l = 0
		for _, e := range m.Deps {
			l += sovGrpcreplica(uint64(e))
		}
		n += 1 + sovGrpcreplica(uint64(l)) + l
	}
	return n
}

func (m *PreAcceptanceReply) Size() (n int) {
	var l int
	_ = l
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	if m.Ok {
		n += 2
	}
	if m.Ballot != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Ballot))
	}
	if m.Seq != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		l = 0
		for _, e := range m.Deps {
			l += sovGrpcreplica(uint64(e))
		}
		n += 1 + sovGrpcreplica(uint64(l)) + l
	}
	if len(m.CommittedDeps) > 0 {
		l = 0
		for _, e := range m.CommittedDeps {
			l += sovGrpcreplica(uint64(e))
		}
		n += 1 + sovGrpcreplica(uint64(l)) + l
	}
	return n
}

func (m *PreAcceptanceOk) Size() (n int) {
	var l int
	_ = l
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	return n
}

func (m *Acceptance) Size() (n int) {
	var l int
	_ = l
	if m.Leader != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Leader))
	}
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	if m.Ballot != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Ballot))
	}
	if m.Count != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Count))
	}
	if m.Seq != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		l = 0
		for _, e := range m.Deps {
			l += sovGrpcreplica(uint64(e))
		}
		n += 1 + sovGrpcreplica(uint64(l)) + l
	}
	return n
}

func (m *AcceptanceReply) Size() (n int) {
	var l int
	_ = l
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	if m.Ok {
		n += 2
	}
	if m.Ballot != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Ballot))
	}
	return n
}

func (m *TryCommit) Size() (n int) {
	var l int
	_ = l
	if m.Leader != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Leader))
	}
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 1 + l + sovGrpcreplica(uint64(l))
		}
	}
	if m.Seq != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		l = 0
		for _, e := range m.Deps {
			l += sovGrpcreplica(uint64(e))
		}
		n += 1 + sovGrpcreplica(uint64(l)) + l
	}
	return n
}

func (m *TryCommitShort) Size() (n int) {
	var l int
	_ = l
	if m.Leader != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Leader))
	}
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	if m.Count != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Count))
	}
	if m.Seq != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		l = 0
		for _, e := range m.Deps {
			l += sovGrpcreplica(uint64(e))
		}
		n += 1 + sovGrpcreplica(uint64(l)) + l
	}
	return n
}

func (m *TryPreAcceptance) Size() (n int) {
	var l int
	_ = l
	if m.Leader != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Leader))
	}
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	if m.Ballot != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Ballot))
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 1 + l + sovGrpcreplica(uint64(l))
		}
	}
	if m.Seq != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Seq))
	}
	if len(m.Deps) > 0 {
		l = 0
		for _, e := range m.Deps {
			l += sovGrpcreplica(uint64(e))
		}
		n += 1 + sovGrpcreplica(uint64(l)) + l
	}
	return n
}

func (m *TryPreAcceptanceReply) Size() (n int) {
	var l int
	_ = l
	if m.Acceptor != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Acceptor))
	}
	if m.Replica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Replica))
	}
	if m.Instance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Instance))
	}
	if m.Ok {
		n += 2
	}
	if m.Ballot != 0 {
		n += 1 + sovGrpcreplica(uint64(m.Ballot))
	}
	if m.ConflictReplica != 0 {
		n += 1 + sovGrpcreplica(uint64(m.ConflictReplica))
	}
	if m.ConflictInstance != 0 {
		n += 1 + sovGrpcreplica(uint64(m.ConflictInstance))
	}
	if m.ConflictStatus != 0 {
		n += 1 + sovGrpcreplica(uint64(m.ConflictStatus))
	}
	return n
}

func sovGrpcreplica(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGrpcreplica(x uint64) (n int) {
	return sovGrpcreplica(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PreAcceptReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (PreAcceptReply_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAcceptanceReply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreAcceptanceReply == nil {
				m.PreAcceptanceReply = &PreAcceptanceReply{}
			}
			if err := m.PreAcceptanceReply.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAcceptanceOk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreAcceptanceOk == nil {
				m.PreAcceptanceOk = &PreAcceptanceOk{}
			}
			if err := m.PreAcceptanceOk.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Empty) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		switch fieldNum {
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Command) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Operation |= (Command_Operation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ClientProposal) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandId", wireType)
			}
			m.CommandId = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommandId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ProposalReplyTS) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Command |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ProposalRead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandId", wireType)
			}
			m.CommandId = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommandId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ProposalReadReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Command |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			m.Ok = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ok |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Beacon) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *BeaconReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *PingArgs) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActAsLeader", wireType)
			}
			m.ActAsLeader = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ActAsLeader |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Preparation) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Leader |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *PreparationReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acceptor", wireType)
			}
			m.Acceptor = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Acceptor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &Command{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Deps = append(m.Deps, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Deps = append(m.Deps, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *PreAcceptance) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Leader |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &Command{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Deps = append(m.Deps, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Deps = append(m.Deps, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *PreAcceptanceReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Deps = append(m.Deps, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Deps = append(m.Deps, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
		case 7:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CommittedDeps = append(m.CommittedDeps, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CommittedDeps = append(m.CommittedDeps, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedDeps", wireType)
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *PreAcceptanceOk) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Acceptance) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Leader |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Deps = append(m.Deps, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Deps = append(m.Deps, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *AcceptanceReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TryCommit) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Leader |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &Command{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Deps = append(m.Deps, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Deps = append(m.Deps, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TryCommitShort) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Leader |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Deps = append(m.Deps, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Deps = append(m.Deps, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TryPreAcceptance) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Leader |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &Command{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Deps = append(m.Deps, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Deps = append(m.Deps, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TryPreAcceptanceReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acceptor", wireType)
			}
			m.Acceptor = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Acceptor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			m.Instance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			m.Ballot = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ballot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictReplica", wireType)
			}
			m.ConflictReplica = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ConflictReplica |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictInstance", wireType)
			}
			m.ConflictInstance = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ConflictInstance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictStatus", wireType)
			}
			m.ConflictStatus = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ConflictStatus |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipGrpcreplica(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGrpcreplica
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func skipGrpcreplica(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGrpcreplica
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGrpcreplica(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGrpcreplica = fmt.Errorf("proto: negative length found during unmarshaling")
)
